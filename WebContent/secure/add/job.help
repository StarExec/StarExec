<h1>Running jobs</h1>

<h2>Creating jobs</h2>

<p>To create and (immediately) execute a job, select "Create job" from
the space explorer page.  Then set the given execution parameters such as
including wall clock timeout and CPU timeout (see <a
href="http://en.wikipedia.org/wiki/Wall-clock_time">here</a> for the
difference).  
</p>

<h2>Options for Creating Jobs</h2>

<h3>Selecting an execution queue</h3>

<p>You can also select a queue for execution of your job.
Each job queue is assigned a number of nodes with identical technical specs.
The queues all.q and all2.q are always available for all users to use.
They differ in the kind of compute nodes that are assigned to them.
Those in all2.q are slightly slower and have less RAM.
Community leaders may request the creation of new queues for exclusive access 
to nodes, for special, community-related tasks (such as running a competition).  
</p>

<h3>Choosing a pre processor</h3>

<p>With this option you can choose a benchmark pre processor that will alter the 
benchmarks before the solvers on them.</p>

<h3>Choosing a post processor<h3>

<p>With this option you can select a post processor that will extract attributes from the
job results as defined by the post processor.</p>

<h3>Timeouts</h3>
<p>Timeouts are specified in number of seconds. Any job pairs that exceed the wallclock timeout or cpu 
timeout you specify will be terminated. Using these options will ensure that job pairs that are 
taking an unreasonable amount of time won't keep your other pairs from running.</p>

<h3>Maximum Memory</h3>
<p>The units for the maximum memory field is Gigabytes. This option limits the amount of memory a pair can use
before it is terminated.</p>

<h2> Advanced Options </h2>

<h3>Choosing an execution order</h3>

<p>There is an option to execute job pairs in depth-first order, which will
execute all job pairs in one subspace before moving on to the next; or
else round-robin, which will result in a workload where all subspaces
make progress in the execution concurrently.  After setting these
options, select "next".
</p>

<h3>Create Paused</h3>
<p>The "Create Paused" option will pause the job as soon as it is created.</p>

<h3>pre-processor seed</h3>
<p>This option allows you to specify the seed for a pseudo-random value generator that will
generate a number and pass it to the preprocessor</p>

<h3>Suppress Timestamps</h3>
<p>Setting this option to "yes" will prevent runsolver from adding timestamps to the jobpair output.</p>

<h3>Results Interval</h3>
<p>The interval, in seconds, at which to receive incremental results for pairs that are running. 0 means results
are only obtained after pairs finish. 10 is the minimum if this is used.</p>

<h3>Save Additional Output Files</h3>


<p>You can then select whether to "run and keep the hierarchy structure" or
choose which benchmarks and solvers to execute.  The first option will find 
all subspaces in the current hierarchy (rooted at the node where you are 
creating the job) which have solvers and benchmarks, and execute all possible 
combinations of those benchmarks and solvers.  So to run several divisions of 
a competition, for example, you can create a subspace for each division, 
copy the solvers and benchmarks for that division into that subspace, and
the run a single job from the space containing those subspaces.
</p>

<h2>Monitoring the execution</h3>

<p>Once the job is created, it will begin queueing immediately.  If
other jobs are running, of course, it may take some time for your job
to make it through the queue to execute on the compute nodes.  
You can look at the <a href="explore/cluster.jsp">cluster status page</a> 
to monitor queues and nodes.
</p>

